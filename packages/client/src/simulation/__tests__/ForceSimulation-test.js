jest.mock('d3-force');
jest.mock('../../elements/ShapeDefinition');
jest.mock('../StateChanges');

import ForceSimulation from '../ForceSimulation';

import * as d3 from 'd3-force';

import MockShapeDefinition from '../../elements/ShapeDefinition';
import { StateChange } from '../StateChanges';

describe('ForceSimulation', () => {
  let d3Simulation;
  let d3ForceCollide;

  beforeEach(() => {
    d3Simulation = {
      force: jest.fn(),
      on: jest.fn(),
      nodes: jest.fn(),
    };
    d3Simulation.force.mockReturnValue(d3Simulation);
    d3Simulation.nodes.mockReturnValue(d3Simulation);
    d3Simulation.on.mockReturnValue(d3Simulation);
    d3.forceSimulation.mockReturnValue(d3Simulation);

    d3ForceCollide = {
      radius: jest.fn(),
    };
    d3ForceCollide.radius.mockReturnValue(d3ForceCollide);
    d3.forceCollide.mockReturnValue(d3ForceCollide);
  });

  it('initializes a simulation with base forces', () => {
    const simulation = new ForceSimulation();

    expect(d3.forceSimulation).toHaveBeenCalled();

    expect(d3Simulation.on).toHaveBeenCalled();
    expect(d3Simulation.force).toHaveBeenCalledWith(
      'preventCollisions', d3ForceCollide
    );
    expect(d3Simulation.force).toHaveBeenCalledWith(
      'ruleForce', expect.any(Function)
    );

    expect(d3Simulation.force).toHaveBeenCalledTimes(2);
    expect(d3ForceCollide.radius).toHaveBeenCalledWith(expect.functionThatReturns([
      { input: { shape: new MockShapeDefinition({ radius: 4 }) }, output: 4 },
      { input: { shape: new MockShapeDefinition({ radius: 5 }) }, output: 5 },
      { input: { shape: new MockShapeDefinition({ radius: 6 }) }, output: 6 },
    ]));
  });

  describe('registerElement', () => {
    it('adds the element to the simulation', () => {
      const shape1 = new MockShapeDefinition();
      const shape2 = new MockShapeDefinition();
      const shape3 = new MockShapeDefinition();
      new ForceSimulation()
        .registerElement('1', shape1)
        .registerElement('2', shape2)
        .registerElement('3', shape3);

      expect(d3Simulation.nodes).toHaveBeenCalledWith([
        { id: '1', x: 0, y: 0, vx: 0, vy: 0, shape: shape1 },
      ]);
      expect(d3Simulation.nodes).toHaveBeenCalledWith([
        { id: '1', x: 0, y: 0, vx: 0, vy: 0, shape: shape1 },
        { id: '2', x: 0, y: 0, vx: 0, vy: 0, shape: shape2 },
      ]);
      expect(d3Simulation.nodes).toHaveBeenCalledWith([
        { id: '1', x: 0, y: 0, vx: 0, vy: 0, shape: shape1 },
        { id: '2', x: 0, y: 0, vx: 0, vy: 0, shape: shape2 },
        { id: '3', x: 0, y: 0, vx: 0, vy: 0, shape: shape3 },
      ]);
      expect(d3Simulation.nodes).toHaveBeenCalledTimes(3);
    });
  });

  describe('registerRule', () => {

    const callRuleForce = (alpha) => {
      const ruleForce = d3Simulation.force.mock.calls.find(e => e[0] === 'ruleForce')[1]
      ruleForce(alpha || 1.0);
    };

    it('adds rules to the runtime rule set', () => {
      const rule1 = jest.fn().mockReturnValue([]);
      const rule2 = jest.fn().mockReturnValue([]);
      const simulation = new ForceSimulation().registerRule(rule1);

      callRuleForce();

      expect(rule1).toHaveBeenCalled();
      expect(rule2).not.toHaveBeenCalled();

      simulation.registerRule(rule2)

      callRuleForce();

      expect(rule1).toHaveBeenCalledTimes(2);
      expect(rule2).toHaveBeenCalledTimes(1);

    });

    describe('ruleForce', () => {
      it('does nothing if there are no elements', () => {
        new ForceSimulation();
        callRuleForce();
      });

      it('applies state changes generated by rules to the appropriate elements', () => {
        const stateChange1 = new StateChange(['element-1']);
        const stateChange2 = new StateChange(['element-2']);
        const stateChange3 = new StateChange(['element-2', 'element-3']);

        const rule1 = jest.fn().mockReturnValue([
          stateChange1,
          stateChange2,
        ]);
        const rule2 = jest.fn().mockReturnValue([
          stateChange3,
        ]);
        const simulation = new ForceSimulation()
          .registerElement('element-1')
          .registerElement('element-2')
          .registerElement('element-3')
          .registerRule(rule1)
          .registerRule(rule2);

        expect(rule1).not.toHaveBeenCalled();
        expect(rule2).not.toHaveBeenCalled();

        expect(stateChange1.apply).not.toHaveBeenCalled();
        expect(stateChange2.apply).not.toHaveBeenCalled();
        expect(stateChange3.apply).not.toHaveBeenCalled();

        callRuleForce(0.75);

        expect(stateChange1.apply).toHaveBeenCalledOnceWith(0.75, simulation.elements['element-1']);
        expect(stateChange2.apply).toHaveBeenCalledOnceWith(0.75, simulation.elements['element-2']);
        expect(stateChange3.apply).toHaveBeenCalledWith(0.75, simulation.elements['element-2']);
        expect(stateChange3.apply).toHaveBeenCalledWith(0.75, simulation.elements['element-3']);
        expect(stateChange3.apply).toHaveBeenCalledTimes(2);
      });
    });
  });

  describe('onNewLayout', () => {
    it('adds a listener to the simulation\'s \'tick\' event', () => {
      const listener = jest.fn();
      const simulation = new ForceSimulation().onNewLayout(listener);
      expect(d3Simulation.on).toHaveBeenCalledWith('tick', expect.functionWithSideEffect({
        before: () => expect(listener).not.toHaveBeenCalled(),
        after: () => expect(listener).toHaveBeenCalledWith(simulation),
        reset: () => listener.mockClear()
      }));
    });
  });
});
