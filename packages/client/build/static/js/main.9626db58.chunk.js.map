{"version":3,"sources":["graph/GraphElementType.js","components/Edge.js","simulation/D3ForceSimulation.js","components/Graph.js","components/Node.js","serviceWorker.js","index.js","App.js"],"names":["GraphElementType","NODE","Symbol","EDGE","Edge","React","Component","render","color","thickness","position","this","props","react_default","a","createElement","x1","from","x","y1","y","x2","to","y2","style","stroke","strokeWidth","fromNodeId","PropTypes","string","isRequired","toNodeId","shape","number","distance","D3ForceSimulation","constructor","options","Object","assign","nodes","edges","width","height","nodeIndex","reduce","obj","n","i","nodeId","map","e","source","target","simulation","d3","force","d","onNewLayout","listener","on","getNodePosition","node","_getNodeById","getEdgePosition","sourceNodeId","targetNodeId","copyProps","c","isNode","type","elementType","isEdge","Graph","super","other","children","forEach","push","state","simulationCreator","setState","border","xmlns","viewBox","className","Children","child","cloneElement","func","bool","Node","radius","r","fill","cx","cy","Boolean","window","location","hostname","match","ReactDOM","Graph_Graph","Node_Node","Edge_Edge","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9626db58.chunk.js","sourcesContent":["export default {\n  NODE: Symbol('NODE'),\n  EDGE: Symbol('EDGE'),\n}\n","import GraphElementType from 'graph/GraphElementType';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nexport default class Edge extends React.Component {\n  static elementType = GraphElementType.EDGE;\n\n  static propTypes = {\n    fromNodeId: PropTypes.string.isRequired,\n    toNodeId: PropTypes.string.isRequired,\n    position: PropTypes.shape({\n      from: PropTypes.shape({\n        x: PropTypes.number.isRequired,\n        y: PropTypes.number.isRequired,\n      }).isRequired,\n      to: PropTypes.shape({\n        x: PropTypes.number.isRequired,\n        y: PropTypes.number.isRequired,\n      }).isRequired,\n    }),\n    color: PropTypes.string,\n    thickness: PropTypes.number,\n    distance: PropTypes.number,\n  }\n\n  static defaultProps = {\n    color: '#c7c7c7',\n    thickness: 1,\n    distance: 100,\n  }\n\n  render() {\n    const { color, thickness, position } = this.props;\n    if (position) {\n      return (\n        <line\n          x1={position.from.x}\n          y1={position.from.y}\n          x2={position.to.x}\n          y2={position.to.y}\n          style={{\n            stroke: color,\n            strokeWidth: thickness,\n          }}\n        />\n      );\n    }\n  }\n\n}\n","import * as d3 from 'd3-force';\n\nexport default class D3ForceSimulation {\n  /**\n   * options:\n   *   nodes: [\n   *     { nodeId: \"string\" },\n   *     ...\n   *   ],\n   *   edges: [\n   *     { from: \"nodeId\", to: \"nodeId\" },\n   *     ...\n   *   ],\n   *   width: the width of the graph,\n   *   height: the height of the graph\n   */\n  constructor(options) {\n    options = Object.assign({\n      nodes: [],\n      edges: [],\n      width: 0,\n      height: 0,\n    }, options);\n\n    this.nodes = options.nodes;\n\n    this.nodeIndex = this.nodes.reduce((obj, n, i) => {\n      obj[n.nodeId] = i;\n      return obj;\n    }, {});\n\n    this.edges = options.edges.map(e => Object.assign(\n      {\n        source: this.nodeIndex[e.fromNodeId],\n        target: this.nodeIndex[e.toNodeId],\n      },\n      e\n    ));\n\n    this.simulation = d3.forceSimulation(this.nodes)\n      .force('charge', d3.forceManyBody())\n      .force(\n        'link', d3.forceLink(this.edges).distance(d => d.distance)\n      )\n      .force('center', d3.forceCenter(options.width / 2, options.height / 2))\n      .force('collision', d3.forceCollide());\n  }\n\n  /**\n   * Attach a listener to run when new layouts are computed.\n   *\n   */\n  onNewLayout(listener) {\n    this.simulation.on('tick', () => listener(this));\n    return this;\n  }\n\n  /**\n   * Find the position of the given node in the current simulation\n   */\n  getNodePosition(nodeId) {\n    const node = this._getNodeById(nodeId);\n    return { x: node.x, y: node.y };\n  }\n\n  /**'\n   * Find the position of the edge between the given nodes in the current simulation\n   */\n  getEdgePosition(sourceNodeId, targetNodeId) {\n    return {\n      from: this.getNodePosition(sourceNodeId),\n      to: this.getNodePosition(targetNodeId),\n    };\n  }\n\n  _getNodeById(nodeId) {\n    return this.nodes[this.nodeIndex[nodeId]];\n  }\n}\n","import GraphElementType from 'graph/GraphElementType';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport D3ForceSimulation from 'simulation/D3ForceSimulation';\n\nconst copyProps = c => Object.assign({}, c.props);\nconst isNode = c => c.type.elementType === GraphElementType.NODE;\nconst isEdge = c => c.type.elementType === GraphElementType.EDGE;\n\n\nexport default class Graph extends React.Component {\n\n  static defaultProps = {\n    simulationCreator: options => new D3ForceSimulation(options),\n    width: 500,\n    height: 500,\n    border: false,\n  }\n\n  static propTypes = {\n    simulationCreator: PropTypes.func,\n    width: PropTypes.number,\n    height: PropTypes.number,\n    border: PropTypes.bool,\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.nodes = [];\n    this.edges = [];\n    this.other = [];\n\n    (this.props.children || []).forEach(c => {\n      if (isNode(c)) {\n        this.nodes.push(c);\n      } else if (isEdge(c)) {\n        this.edges.push(c);\n      } else {\n        this.other.push(c);\n      }\n    });\n\n    this.state = {\n      simulation: this.props.simulationCreator({\n        nodes: this.nodes.map(copyProps),\n        edges: this.edges.map(copyProps),\n        width: this.props.width,\n        height: this.props.height,\n      }).onNewLayout(simulation => this.setState({ simulation }))\n    }\n  }\n\n  render() {\n    const { simulation } = this.state;\n    const { width, height, border } = this.props;\n    const { nodes, edges, other } = this;\n\n    return (\n      <svg\n        xmlns='http://www.w3.org/2000/svg'\n        viewBox={`0 0 ${width} ${height}`}\n        width={width}\n        height={height}\n        style={ border ? { border: '1px solid black' } : {} }\n      >\n        <g className=\"yellow-graph\">\n          <g className=\"nodes\">\n            {\n              React.Children.map(nodes, child => React.cloneElement(\n                child,\n                { position: simulation.getNodePosition(child.props.nodeId) }\n              ))\n            }\n          </g>\n          <g className=\"edges\">\n            {\n              React.Children.map(edges, child => React.cloneElement(\n                child,\n                {\n                  position: simulation.getEdgePosition(\n                    child.props.fromNodeId,\n                    child.props.toNodeId\n                  )\n                }\n              ))\n            }\n          </g>\n          <g className=\"other\">\n            {other}\n          </g>\n        </g>\n      </svg>\n    );\n  }\n}\n","import GraphElementType from 'graph/GraphElementType';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nexport default class Node extends React.Component {\n  static elementType = GraphElementType.NODE;\n\n  static propTypes = {\n    nodeId: PropTypes.string.isRequired,\n    position: PropTypes.shape({\n      x: PropTypes.number.isRequired,\n      y: PropTypes.number.isRequired,\n    }),\n    color: PropTypes.string,\n    radius: PropTypes.number,\n  }\n\n  static defaultProps = {\n    color: '#4286f4',\n    radius: 10,\n  }\n\n  render() {\n    const { color, radius, position } = this.props;\n    if (position) {\n      return <circle r={radius} fill={color} cx={position.x} cy={position.y} />\n    } else {\n      return <circle r={radius} fill={color} />\n    }\n  }\n\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { Component } from 'react';\nimport Edge from './components/Edge';\nimport Graph from './components/Graph';\nimport Node from './components/Node';\n\nexport default class App extends Component {\n  render() {\n    return (\n      <Graph width={1000} height={500} border={true}>\n        <Node nodeId=\"1\" />\n        <Node nodeId=\"2\" />\n        <Node nodeId=\"3\" />\n        <Edge fromNodeId=\"1\" toNodeId=\"3\" distance={50} />\n        <Edge fromNodeId=\"2\" toNodeId=\"3\" distance={150} />\n      </Graph>\n    );\n  }\n}\n"],"sourceRoot":""}